// Wednesday, July 10, 2024
// https://claude.ai/chat/39b1cea7-51b4-4285-b0a7-d0a79661b328
// Generated by Claude, by sending it image/Figure_6.4.png and asking it :
// "Write a CUDA matrix multiplication kernel function that corresponds to the design illustrated in Fig. 6.4."
// This was Exercise 1 at the end of chapter 6.

#define TILE_SIZE 32

__global__ void matrixMulCoalesced(float *A, float *B, float *C, int M, int N, int K) {
    __shared__ float As[TILE_SIZE][TILE_SIZE];
    __shared__ float Bs[TILE_SIZE][TILE_SIZE];
    
    int bx = blockIdx.x;
    int by = blockIdx.y;
    int tx = threadIdx.x;
    int ty = threadIdx.y;
    
    int row = by * TILE_SIZE + ty;
    int col = bx * TILE_SIZE + tx;
    
    float sum = 0.0f;
    
    for (int t = 0; t < (K - 1) / TILE_SIZE + 1; ++t) {
        // Coalesced load for matrix A
        if (row < M && t * TILE_SIZE + tx < K) {
            As[ty][tx] = A[row * K + t * TILE_SIZE + tx];
        } else {
            As[ty][tx] = 0.0f;
        }
        
        // Coalesced load for matrix B with corner turning
        if (t * TILE_SIZE + ty < K && col < N) {
            Bs[ty][tx] = B[(t * TILE_SIZE + ty) * N + col];
        } else {
            Bs[ty][tx] = 0.0f;
        }
        
        __syncthreads();
        
        for (int k = 0; k < TILE_SIZE; ++k) {
            sum += As[ty][k] * Bs[k][tx];
        }
        
        __syncthreads();
    }
    
    if (row < M && col < N) {
        C[row * N + col] = sum;
    }
}