// Generated by Github CoPilot: 

// # Compile the program
// nvcc -o blur blur.cu `pkg-config --cflags --libs opencv4`

// # Run the program with source and target image filenames
// ./blur source_image.jpg target_image.jpg



#include <cuda_runtime.h>
#include <opencv2/opencv.hpp>
#include <iostream>

#define BLUR_SIZE 1

// CUDA kernel for applying box blur
__global__ void blurKernel(unsigned char* input, unsigned char* output, int width, int height) {
    int col = blockIdx.x * blockDim.x + threadIdx.x;
    int row = blockIdx.y * blockDim.y + threadIdx.y;

    if (col < width && row < height) {
        int pixValR = 0, pixValG = 0, pixValB = 0;
        int pixels = 0;

        // Get the average of the surrounding BLUR_SIZE x BLUR_SIZE box
        for (int blurRow = -BLUR_SIZE; blurRow < BLUR_SIZE + 1; ++blurRow) {
            for (int blurCol = -BLUR_SIZE; blurCol < BLUR_SIZE + 1; ++blurCol) {
                int curRow = row + blurRow;
                int curCol = col + blurCol;

                // Verify we have a valid image pixel
                if (curRow > -1 && curRow < height && curCol > -1 && curCol < width) {
                    int offset = (curRow * width + curCol) * 3;
                    pixValR += input[offset];
                    pixValG += input[offset + 1];
                    pixValB += input[offset + 2];
                    pixels++;
                }
            }
        }

        // Write our new pixel value out
        int offset = (row * width + col) * 3;
        output[offset] = (unsigned char)(pixValR / pixels);
        output[offset + 1] = (unsigned char)(pixValG / pixels);
        output[offset + 2] = (unsigned char)(pixValB / pixels);
    }
}

// Function to blur the image using CUDA
void blurImage(unsigned char* input, unsigned char* output, int width, int height) {
    unsigned char *d_input, *d_output;
    size_t imageSize = width * height * 3 * sizeof(unsigned char);

    // Allocate memory on the GPU
    cudaMalloc((void**)&d_input, imageSize);
    cudaMalloc((void**)&d_output, imageSize);

    // Copy the input image to the GPU
    cudaMemcpy(d_input, input, imageSize, cudaMemcpyHostToDevice);

    // Define the block and grid sizes
    dim3 dimBlock(16, 16);
    dim3 dimGrid((width + dimBlock.x - 1) / dimBlock.x, (height + dimBlock.y - 1) / dimBlock.y);

    // Launch the blur kernel
    blurKernel<<<dimGrid, dimBlock>>>(d_input, d_output, width, height);

    // Copy the blurred image back to the host
    cudaMemcpy(output, d_output, imageSize, cudaMemcpyDeviceToHost);

    // Free the allocated GPU memory
    cudaFree(d_input);
    cudaFree(d_output);
}

int main(int argc, char** argv) {
    // Check for the correct number of arguments
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <source_image> <target_image>" << std::endl;
        return -1;
    }

    std::string sourceImage = argv[1];
    std::string targetImage = argv[2];

    // Read the input image using OpenCV
    cv::Mat inputImage = cv::imread(sourceImage, cv::IMREAD_COLOR);
    if (inputImage.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }

    int width = inputImage.cols;
    int height = inputImage.rows;

    // Allocate memory for the output image
    cv::Mat outputImage(height, width, CV_8UC3);

    // Blur the image
    blurImage(inputImage.data, outputImage.data, width, height);

    // Save the output image using OpenCV
    cv::imwrite(targetImage, outputImage);

    return 0;
}